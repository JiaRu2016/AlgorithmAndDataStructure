## C9 排序

排序的定义： key

排序的稳定性

内排序与外排序。内排序：只用内存。
- 时间性能。比较 和 移动
- 辅助空间
- 算法本身的复杂性

### 简单排序算法：冒泡排序 < 选择排序 < 插入排序

时间复杂度（比较次数、移动/交换/拷贝次数）都是平方级 O(n^2)
辅助空间：常数级，几乎不需要额外空间
稳定性：都可以处理成稳定的

#### 冒泡排序

外层i从前往后，里层从后往前，若前者严格大于后者则交换。
优化：flag


- 可以是稳定的
- 时间复杂度 O(n^2)
    - 比较： n(n-1) / 2
    - 交换：最坏（全逆序排列）n(n-1) / 2 即每次比较都需要移动。最好0次。

#### 选择排序

外层i从前往后，里层从i到n找记录最小的index，交换

- 可以是稳定的
- 时间复杂度 O(n^2)
    - 比较： n(n-1)/2 次
    - 交换：最坏（全逆序排列）n-1次，最好0次

#### 插入排序

从后往前比较逐个比较、逐个移动，每次外层循环将当前牌放入正确的位置。

- 可以是稳定的
- 时间复杂度 O(n^2)
    - 比较： 最坏 (n+2)(n-1)/2 次，最好n-1次
    - 移动/拷贝：最坏 (n+4)(n-1)/2次，最好情况0次
    - 最坏是全逆序排列的情况
- 辅助空间：1个单位

### 改进排序算法——突破O(N^2)，获得O(NlogN)

#### 希尔排序 Shell Sort

插入排序什么时候效果好？规模小 or 基本有序

希尔排序：“宏观调控” 分组排序，在局部构造出这两个条件！
具体做法是，按一定的增量分组，在每组内进行插入排序。

- 初期，增量较大时，每组的规模较小
- 随着增量逐渐减小，每组的规模增大，但有序程度也在增大

由于是分组排序，所以不稳定。

时间复杂度分析非常复杂，有些增量序列至今无解。**增量序列**是希尔排序的核心问题

#### 堆排序 Heap Sort

#### 归并排序 Merging Sort

（图）完全二叉树

比较和移动次数相同（每比较一次就移动一个元素）
每个元素都被移动 logN 次 ie. 树的高度
因此总的时间复杂度为 NlogN，无论情况好坏

是稳定的

辅助空间：非递归实现，使用2N空间即可，即空间复杂度为O(N)

#### 快速排序

pivot, 递归

```
def qsort(L, start, end):
    pivoit = partition(L, start, end)
    qsort(L, start, pivoit-1)
    qsort(L, pivoit+1, end)
```

